<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŸ¥è¯†å›¾è°±ç®¡ç†ç³»ç»Ÿ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.6/dist/vis-network.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --success-color: #48bb78;
            --danger-color: #f56565;
            --dark-bg: #1a202c;
            --card-bg: #2d3748;
            --text-primary: #e2e8f0;
            --text-secondary: #a0aec0;
            --border-color: #4a5568;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 40px 0;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            border-radius: 20px;
            margin-bottom: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
        }

        .control-panel {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            height: fit-content;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .file-upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            background: rgba(102, 126, 234, 0.05);
            transition: all 0.3s ease;
        }

        .file-upload-area:hover {
            border-color: var(--primary-color);
            background: rgba(102, 126, 234, 0.1);
        }

        .file-upload-area.drag-over {
            border-color: var(--success-color);
            background: rgba(72, 187, 120, 0.1);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        input[type="file"] {
            display: none;
        }

        .file-info {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: none;
        }

        .file-info.active {
            display: block;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            width: 100%;
            margin-bottom: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color) 0%, #38a169 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger-color) 0%, #e53e3e 100%);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .graph-container {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        #network {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin-bottom: 20px;
        }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .loading-indicator.active {
            display: block;
        }

        .result-panel {
            background: #2d3748;
            border-radius: 12px;
            padding: 25px;
            border: 1px solid #e2e8f0;
            min-height: 400px;
        }

        .result-panel h3 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .result-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        .tab-btn {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #718096;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
        }

        .tab-btn:hover:not(.active) {
            background: rgba(102, 126, 234, 0.1);
        }

        .tab-content {
            display: none;
            max-height: 350px;
            overflow-y: auto;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content::-webkit-scrollbar {
            width: 8px;
        }

        .tab-content::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 4px;
        }

        .tab-content::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        .entity-tag {
            display: inline-block;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 20px;
            font-size: 0.9rem;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
            border: 1px solid var(--primary-color);
            color: #2d3748;
            font-weight: 500;
        }

        .relation-item, .event-item {
            padding: 12px 15px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            color: #2d3748;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .relation-item strong, .event-item strong {
            color: var(--primary-color);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #a0aec0;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .processing-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .processing-overlay.active {
            display: flex;
        }

        .processing-content {
            background: var(--card-bg);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
        }

        .progress-container {
            width: 100%;
            height: 25px;
            background: var(--border-color);
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            margin: 0 auto 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            #network {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>çŸ¥è¯†å›¾è°±ç®¡ç†ç³»ç»Ÿ</h1>
            <p>æ™ºèƒ½æ–‡æ¡£åˆ†æä¸çŸ¥è¯†å›¾è°±æ„å»ºå¹³å°</p>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <div class="section">
                    <h3 class="section-title">æ–‡ä»¶ä¸Šä¼ </h3>
                    <div class="file-upload-area" id="uploadArea">
                        <div class="upload-icon">ğŸ“„</div>
                        <p>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</p>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">
                            æ”¯æŒæ ¼å¼: .txt, .docx, .pdf
                        </p>
                    </div>
                    <input type="file" id="fileInput" accept=".txt,.docx,.pdf">
                    <div class="file-info" id="fileInfo">
                        <strong>å·²é€‰æ‹©æ–‡ä»¶:</strong>
                        <span id="fileName"></span>
                    </div>
                </div>

                <div class="section">
                    <h3 class="section-title">æ“ä½œæ§åˆ¶</h3>
                    <button class="btn btn-primary" id="processBtn" disabled>ç”ŸæˆçŸ¥è¯†å›¾è°±</button>
                    <button class="btn btn-success" id="refreshBtn">åˆ·æ–°å›¾è°±</button>
                    <button class="btn btn-danger" id="clearBtn">æ¸…ç©ºå›¾è°±</button>
                </div>

                <div class="section">
                    <h3 class="section-title">å›¾è°±ç®¡ç†</h3>
                    <button class="btn btn-primary" id="exportBtn">å¯¼å‡ºå›¾è°± (JSON)</button>
                    <button class="btn btn-primary" id="exportCsvBtn">å¯¼å‡ºä¸º CSV</button>

                    <button class="btn btn-success" id="importJsonBtn">å¯¼å…¥å›¾è°± (JSON)</button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;">

                    <button class="btn btn-success" id="importCsvNodesBtn">å¯¼å…¥CSV (èŠ‚ç‚¹)</button>
                    <input type="file" id="importCsvNodesInput" accept=".csv" style="display: none;">

                    <button class="btn btn-success" id="importCsvEdgesBtn">å¯¼å…¥CSV (è¾¹)</button>
                    <input type="file" id="importCsvEdgesInput" accept=".csv" style="display: none;">
                </div>

                <div class="section">
                    <h3 class="section-title">åˆ†æå†å²</h3>
                    <button class="btn btn-primary" id="viewHistoryBtn">æŸ¥çœ‹å†å²</button>
                    <div id="historyList" style="display: none; margin-top: 10px; max-height: 300px; overflow-y: auto;"></div>
                </div>

                <div class="section">
                    <h3 class="section-title">æ˜¾ç¤ºæ§åˆ¶</h3>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">
                            æ˜¾ç¤ºèŠ‚ç‚¹æ•°é‡: <span id="nodeCountLabel" style="color: var(--primary-color); font-weight: bold;">100</span>
                        </label>
                        <input type="range" id="nodeCountSlider" min="10" max="200" value="200" style="width: 100%;">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">å®ä½“ç±»å‹è¿‡æ»¤:</label>
                        <div id="entityTypeFilters" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <label style="display: inline-flex; align-items: center;">
                                <input type="checkbox" checked data-type="PERSON" style="margin-right: 5px;">äººç‰©
                            </label>
                            <label style="display: inline-flex; align-items: center;">
                                <input type="checkbox" checked data-type="ORGANIZATION" style="margin-right: 5px;">æœºæ„
                            </label>
                            <label style="display: inline-flex; align-items: center;">
                                <input type="checkbox" checked data-type="LOCATION" style="margin-right: 5px;">åœ°ç‚¹
                            </label>
                            <label style="display: inline-flex; align-items: center;">
                                <input type="checkbox" checked data-type="PROJECT" style="margin-right: 5px;">é¡¹ç›®
                            </label>
                            <label style="display: inline-flex; align-items: center; grid-column: span 2;">
                                <input type="checkbox" checked data-type="CONCEPT" style="margin-right: 5px;">æ¦‚å¿µ
                            </label>
                        </div>
                    </div>
                    <input type="text" id="searchInput" placeholder="æœç´¢èŠ‚ç‚¹..."
                           style="width: 100%; padding: 8px; border: 1px solid var(--border-color);
                           border-radius: 6px; background: var(--dark-bg); color: var(--text-primary); margin-bottom: 10px;">
                    <button class="btn btn-primary" id="resetFiltersBtn">é‡ç½®è¿‡æ»¤å™¨</button>
                </div>
            </div>

            <div class="graph-container">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="nodeCount">0</div>
                        <div class="stat-label">èŠ‚ç‚¹æ•°é‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="edgeCount">0</div>
                        <div class="stat-label">å…³ç³»æ•°é‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="entityCount">0</div>
                        <div class="stat-label">å®ä½“æ•°é‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="eventCount">0</div>
                        <div class="stat-label">äº‹ä»¶æ•°é‡</div>
                    </div>
                </div>

                <div style="position: relative;">
                    <div id="network"></div>
                    <div class="loading-indicator" id="loadingIndicator">
                        <div class="spinner" style="width: 30px; height: 30px;"></div>
                        <p>æ­£åœ¨æ¸²æŸ“å›¾è°±...</p>
                    </div>
                </div>

                <div class="result-panel" id="resultPanel">
                    <h3>ğŸ“Š åˆ†æç»“æœ</h3>
                    <div class="result-tabs">
                        <button class="tab-btn active" data-tab="entities">å®ä½“</button>
                        <button class="tab-btn" data-tab="relations">å…³ç³»</button>
                        <button class="tab-btn" data-tab="events">äº‹ä»¶</button>
                        <button class="tab-btn" data-tab="enhanced">è¯­ä¹‰å¢å¼º</button>
                    </div>
                    <div class="tab-content active" id="entities-tab">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ·ï¸</div>
                            <p>æš‚æ— å®ä½“æ•°æ®</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è‡ªåŠ¨è¯†åˆ«å®ä½“</p>
                        </div>
                    </div>
                    <div class="tab-content" id="relations-tab">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ”—</div>
                            <p>æš‚æ— å…³ç³»æ•°æ®</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è‡ªåŠ¨æå–å…³ç³»</p>
                        </div>
                    </div>
                    <div class="tab-content" id="events-tab">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“…</div>
                            <p>æš‚æ— äº‹ä»¶æ•°æ®</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è‡ªåŠ¨è¯†åˆ«äº‹ä»¶</p>
                        </div>
                    </div>
                    <div class="tab-content" id="enhanced-tab">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ§ </div>
                            <p>æš‚æ— è¯­ä¹‰å¢å¼ºæ•°æ®</p>
                            <p style="font-size: 0.9rem; margin-top: 10px;">ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è¿›è¡Œè¯­ä¹‰å¢å¼º</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-content">
            <div class="spinner"></div>
            <h2>æ­£åœ¨å¤„ç†...</h2>
            <p id="processingMessage">æ­£åœ¨åˆ†ææ–‡æ¡£å¹¶æ„å»ºçŸ¥è¯†å›¾è°±</p>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">0%</div>
            </div>
            <button class="btn btn-danger" id="cancelBtn" style="margin-top: 20px;">å–æ¶ˆå¤„ç†</button>
        </div>
    </div>

    <script>
    let network = null;
    let selectedFile = null;
    let currentTaskId = null;
    let progressInterval = null;
    let isProcessingComplete = false;
    let allNodes = new vis.DataSet([]);
    let allEdges = new vis.DataSet([]);
    let filteredNodes = new vis.DataSet([]);
    let filteredEdges = new vis.DataSet([]);

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function() {
        initializeNetwork();
        initFileUpload();
        initButtons();
        initFilters();
        loadGraph().then(() => loadLatestAnalysis());
    });

    // åˆå§‹åŒ–ç½‘ç»œå›¾
    function initializeNetwork() {
        const container = document.getElementById('network');
        const options = {
            nodes: {
                shape: 'dot',
                size: 15,
                font: { size: 12, color: '#ffffff' }
            },
            edges: {
                font: { size: 10, color: '#a0aec0' },
                arrows: { to: { enabled: true, scaleFactor: 0.6 } }
            },
            physics: {
                enabled: true,
                barnesHut: { gravitationalConstant: -2000, centralGravity: 0.1, springLength: 80 }
            }
        };
        network = new vis.Network(container, { nodes: filteredNodes, edges: filteredEdges }, options);
        network.on('stabilizationIterationsDone', () => {
            document.getElementById('loadingIndicator').classList.remove('active');
        });
    }

    // åˆå§‹åŒ–æ–‡ä»¶ä¸Šä¼ 
    function initFileUpload() {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', function(e) {
            e.stopPropagation();
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) handleFile(e.target.files[0]);
        });

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });
    }

    // å¤„ç†æ–‡ä»¶é€‰æ‹©
    function handleFile(file) {
        const validTypes = ['.txt', '.docx', '.pdf'];
        const fileExt = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();

        if (!validTypes.includes(fileExt)) {
            alert('è¯·é€‰æ‹©æ”¯æŒçš„æ–‡ä»¶æ ¼å¼!');
            return;
        }

        if (file.size > 50 * 1024 * 1024) {
            alert('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡50MB!');
            return;
        }

        selectedFile = file;
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileInfo').classList.add('active');
        document.getElementById('processBtn').disabled = false;
    }

    // åˆå§‹åŒ–æŒ‰é’®
    function initButtons() {
        document.getElementById('processBtn').addEventListener('click', processDocument);
        document.getElementById('refreshBtn').addEventListener('click', loadGraph);
        document.getElementById('clearBtn').addEventListener('click', clearGraph);
        document.getElementById('resetFiltersBtn').addEventListener('click', resetFilters);
        document.getElementById('exportBtn').addEventListener('click', exportGraph);
        document.getElementById('exportCsvBtn').addEventListener('click', exportGraphAsCsv);

        // JSONå¯¼å…¥ - ä¿®å¤ç‚¹å‡»é—®é¢˜
        const importJsonBtn = document.getElementById('importJsonBtn');
        const importFileInput = document.getElementById('importFileInput');

        if (importJsonBtn && importFileInput) {
            importJsonBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('ğŸ”µ JSONå¯¼å…¥æŒ‰é’®è¢«ç‚¹å‡»');
                importFileInput.value = '';
                setTimeout(() => {
                    importFileInput.click();
                }, 10);
            };

            importFileInput.onchange = function(e) {
                console.log('ğŸ“ æ–‡ä»¶å·²é€‰æ‹©:', e.target.files[0]?.name);
                handleImportFile(e);
            };
        }

        // CSVèŠ‚ç‚¹å¯¼å…¥ - ä¿®å¤ç‚¹å‡»é—®é¢˜
        const importCsvNodesBtn = document.getElementById('importCsvNodesBtn');
        const importCsvNodesInput = document.getElementById('importCsvNodesInput');

        if (importCsvNodesBtn && importCsvNodesInput) {
            importCsvNodesBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('ğŸ”µ CSVèŠ‚ç‚¹å¯¼å…¥æŒ‰é’®è¢«ç‚¹å‡»');
                importCsvNodesInput.value = '';
                setTimeout(() => {
                    importCsvNodesInput.click();
                }, 10);
            };

            importCsvNodesInput.onchange = function(e) {
                console.log('ğŸ“ èŠ‚ç‚¹æ–‡ä»¶å·²é€‰æ‹©:', e.target.files[0]?.name);
                handleCsvNodesImport(e);
            };
        }

        // CSVè¾¹å¯¼å…¥ - ä¿®å¤ç‚¹å‡»é—®é¢˜
        const importCsvEdgesBtn = document.getElementById('importCsvEdgesBtn');
        const importCsvEdgesInput = document.getElementById('importCsvEdgesInput');

        if (importCsvEdgesBtn && importCsvEdgesInput) {
            importCsvEdgesBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('ğŸ”µ CSVè¾¹å¯¼å…¥æŒ‰é’®è¢«ç‚¹å‡»');
                importCsvEdgesInput.value = '';
                setTimeout(() => {
                    importCsvEdgesInput.click();
                }, 10);
            };

            importCsvEdgesInput.onchange = function(e) {
                console.log('ğŸ“ è¾¹æ–‡ä»¶å·²é€‰æ‹©:', e.target.files[0]?.name);
                handleCsvEdgesImport(e);
            };
        }

        document.getElementById('viewHistoryBtn').addEventListener('click', toggleHistoryView);
        document.getElementById('cancelBtn').addEventListener('click', () => {
            if (progressInterval) clearInterval(progressInterval);
            isProcessingComplete = true;
            showProcessing(false);
        });

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
    }

    // åˆå§‹åŒ–è¿‡æ»¤å™¨
    function initFilters() {
        document.getElementById('nodeCountSlider').addEventListener('input', (e) => {
            document.getElementById('nodeCountLabel').textContent = e.target.value;
            throttledFilterGraph();
        });

        document.querySelectorAll('#entityTypeFilters input').forEach(cb => {
            cb.addEventListener('change', throttledFilterGraph);
        });

        document.getElementById('searchInput').addEventListener('input', throttledFilterGraph);
    }

    // èŠ‚æµå‡½æ•°
    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    const throttledFilterGraph = throttle(filterGraph, 300);

    // è¿‡æ»¤å›¾è°± - å®Œå…¨ä¿®å¤çš„ç‰ˆæœ¬
    function filterGraph() {
        if (!allNodes || allNodes.length === 0) {
            console.log('âš ï¸ æ²¡æœ‰æ•°æ®');
            return;
        }

        const maxNodes = parseInt(document.getElementById('nodeCountSlider').value) || 200;
        const searchTerm = (document.getElementById('searchInput').value || '').trim().toLowerCase();

        let allNodeData = allNodes.get();
        let allEdgeData = allEdges.get();

        // â­ ç®€åŒ–ï¼šåªæŒ‰æœç´¢è¯è¿‡æ»¤ï¼Œä¸è¿‡æ»¤ç±»å‹
        let filtered = allNodeData;

        if (searchTerm) {
            filtered = allNodeData.filter(node => {
                return (node.label && node.label.toLowerCase().includes(searchTerm)) ||
                       (node.id && String(node.id).toLowerCase().includes(searchTerm));
            });
        }

        // é™åˆ¶æ•°é‡
        filtered = filtered.slice(0, maxNodes);

        // è¿‡æ»¤è¾¹
        const visibleIds = new Set(filtered.map(n => n.id));
        const filteredEdgeData = allEdgeData.filter(e =>
            visibleIds.has(e.from) && visibleIds.has(e.to)
        );

        // æ›´æ–°æ˜¾ç¤º
        filteredNodes.clear();
        filteredEdges.clear();

        if (filtered.length > 0) filteredNodes.add(filtered);
        if (filteredEdgeData.length > 0) filteredEdges.add(filteredEdgeData);

        document.getElementById('nodeCount').textContent = filtered.length;
        document.getElementById('edgeCount').textContent = filteredEdgeData.length;

        if (network && filtered.length > 0) {
            setTimeout(() => {
                try {
                    network.fit();
                } catch(e) {
                    console.warn('è§†å›¾è°ƒæ•´å¤±è´¥:', e);
                }
            }, 500);
        }

        console.log('âœ… æ˜¾ç¤º', filtered.length, 'ä¸ªèŠ‚ç‚¹');
    }

    // é‡ç½®è¿‡æ»¤å™¨
    function resetFilters() {
        document.getElementById('nodeCountSlider').value = 200;
        document.getElementById('nodeCountLabel').textContent = '200';
        document.getElementById('searchInput').value = '';
        document.querySelectorAll('#entityTypeFilters input').forEach(cb => cb.checked = true);
        filterGraph();
    }

    // å¤„ç†æ–‡æ¡£
    async function processDocument() {
        if (!selectedFile) {
            alert('è¯·å…ˆé€‰æ‹©æ–‡ä»¶!');
            return;
        }

        const formData = new FormData();
        formData.append('file', selectedFile);
        isProcessingComplete = false;
        showProcessing(true, 'æ­£åœ¨å¯åŠ¨å¤„ç†...');

        try {
            const response = await fetch('/process_document_async', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const result = await response.json();
            if (result.task_id) {
                currentTaskId = result.task_id;
                startProgressMonitoring(result.task_id);
            }
        } catch (error) {
            console.error('å¤„ç†å¤±è´¥:', error);
            alert('å¤„ç†å¤±è´¥: ' + error.message);
            showProcessing(false);
            isProcessingComplete = true;
        }
    }

    // ç›‘æ§è¿›åº¦
    function startProgressMonitoring(taskId) {
        progressInterval = setInterval(async () => {
            if (isProcessingComplete) {
                clearInterval(progressInterval);
                return;
            }

            try {
                const response = await fetch(`/processing_status/${taskId}`);
                if (!response.ok) throw new Error(`çŠ¶æ€æŸ¥è¯¢å¤±è´¥: ${response.status}`);

                const status = await response.json();
                updateProgressBar(status.progress || 0);
                document.getElementById('processingMessage').textContent = status.message || 'å¤„ç†ä¸­...';

                if (status.status === 'completed' && !isProcessingComplete) {
                    isProcessingComplete = true;
                    clearInterval(progressInterval);

                    console.log('å¤„ç†å®Œæˆ,å¼€å§‹åˆ·æ–°æ•°æ®');

                    if (status.result) {
                        console.log('æ˜¾ç¤ºåˆ†æç»“æœ');
                        displayResults(status.result);
                    }

                    setTimeout(async () => {
                        console.log('åˆ·æ–°å›¾è°±æ•°æ®');
                        await loadGraph();
                        showProcessing(false);

                        const graphData = status.result?.graph;
                        const nodeCount = graphData?.graph?.nodes?.length || 0;
                        const edgeCount = graphData?.graph?.edges?.length || 0;

                        alert(`æ–‡æ¡£å¤„ç†æˆåŠŸ!è€—æ—¶ ${status.processing_time?.toFixed(2)}ç§’\n\nèŠ‚ç‚¹: ${nodeCount}\nå…³ç³»: ${edgeCount}\näº‹ä»¶: ${status.result?.events?.events?.length || 0}`);
                    }, 1000);

                } else if (status.status === 'error' && !isProcessingComplete) {
                    isProcessingComplete = true;
                    clearInterval(progressInterval);
                    showProcessing(false);
                    alert('å¤„ç†å¤±è´¥: ' + (status.error || status.message));
                }
            } catch (error) {
                console.error('è¿›åº¦æŸ¥è¯¢é”™è¯¯:', error);
            }
        }, 2000);
    }

    // æ›´æ–°è¿›åº¦æ¡
    function updateProgressBar(progress) {
        const bar = document.getElementById('progressBar');
        bar.style.width = progress + '%';
        bar.textContent = progress + '%';
    }

    // åŠ è½½å›¾è°±
    async function loadGraph() {
        try {
            console.log('å¼€å§‹åŠ è½½å›¾è°±...');
            const response = await fetch('/get_graph');
            const data = await response.json();

            console.log('å›¾è°±æ•°æ®:', data);
            console.log('èŠ‚ç‚¹æ•°:', data.nodes?.length, 'è¾¹æ•°:', data.edges?.length);

            if (!data.nodes || data.nodes.length === 0) {
                console.warn('å›¾è°±ä¸ºç©º');
                return;
            }

            updateGraph(data);
            console.log('å›¾è°±æ›´æ–°å®Œæˆ');
        } catch (error) {
            console.error('åŠ è½½å›¾è°±é”™è¯¯:', error);
        }
    }

    // æ›´æ–°å›¾è°±
    function updateGraph(data) {
        console.log('ğŸ“„ å¼€å§‹æ›´æ–°å›¾è°±, èŠ‚ç‚¹:', data.nodes?.length, 'è¾¹:', data.edges?.length);

        if (!data || !data.nodes || !data.edges) {
            console.error('âŒ å›¾è°±æ•°æ®æ ¼å¼é”™è¯¯');
            return;
        }

        const nodeColors = {
            'PERSON': '#667eea',
            'ORGANIZATION': '#ed8936',
            'LOCATION': '#48bb78',
            'PROJECT': '#f6ad55',
            'CONCEPT': '#fc8181',
            'default': '#718096'
        };

        const nameToIdMap = new Map();
        const nodeData = data.nodes.map((node, index) => {
            const nodeId = node.name || node.id || `node_${index}`;
            const nodeName = node.label || node.name || nodeId;

            nameToIdMap.set(nodeName, nodeId);
            nameToIdMap.set(nodeId, nodeId);

            return {
                id: nodeId,
                label: nodeName,
                type: node.type || 'default',
                color: nodeColors[node.type] || nodeColors.default,
                title: `${nodeName}\nç±»å‹: ${node.type || 'Unknown'}\n${node.description || ''}`,
                description: node.description || ''
            };
        });

        console.log('âœ… èŠ‚ç‚¹å¤„ç†å®Œæˆ:', nodeData.length);
        console.log('ğŸ“‹ åç§°æ˜ å°„è¡¨å¤§å°:', nameToIdMap.size);

        const edgeData = data.edges.map((edge, i) => {
            const source = edge.source || edge.from;
            const target = edge.target || edge.to;

            const fromId = nameToIdMap.get(source) || source;
            const toId = nameToIdMap.get(target) || target;

            const fromExists = nodeData.some(n => n.id === fromId);
            const toExists = nodeData.some(n => n.id === toId);

            if (!fromExists || !toExists) {
                console.warn(`âš ï¸ è¾¹ ${i} çš„èŠ‚ç‚¹ä¸å­˜åœ¨:`, {
                    source, target, fromId, toId, fromExists, toExists
                });
                return null;
            }

            return {
                id: `edge_${i}`,
                from: fromId,
                to: toId,
                label: edge.type || edge.relation || '',
                arrows: 'to',
                title: edge.type || edge.relation || '',
                color: edge.inferred ? { color: '#ffc107' } : undefined
            };
        }).filter(edge => edge !== null);

        console.log('âœ… è¾¹å¤„ç†å®Œæˆ:', edgeData.length, '(è¿‡æ»¤å‰:', data.edges.length, ')');

        try {
            allNodes.clear();
            allEdges.clear();

            if (nodeData.length > 0) {
                allNodes.add(nodeData);
            }

            if (edgeData.length > 0) {
                allEdges.add(edgeData);
            }

            console.log('âœ… å…¨å±€æ•°æ®é›†å·²æ›´æ–°');

            filterGraph();

            setTimeout(() => {
                if (network && nodeData.length > 0) {
                    network.fit();
                    console.log('âœ… è§†å›¾å·²è°ƒæ•´');
                }
            }, 1000);

        } catch (error) {
            console.error('âŒ å›¾è°±æ›´æ–°å¤±è´¥:', error);
        }
    }

    // æ¸…ç©ºå›¾è°±
    async function clearGraph() {
        if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ•´ä¸ªå›¾è°±å—?')) return;

        try {
            const response = await fetch('/clear_graph', { method: 'POST' });
            if (response.ok) {
                allNodes.clear();
                allEdges.clear();
                filteredNodes.clear();
                filteredEdges.clear();
                document.getElementById('nodeCount').textContent = '0';
                document.getElementById('edgeCount').textContent = '0';
                document.getElementById('entityCount').textContent = '0';
                document.getElementById('eventCount').textContent = '0';

                resetResultPanels();
                alert('å›¾è°±å·²æ¸…ç©º!');
            }
        } catch (error) {
            console.error('æ¸…ç©ºé”™è¯¯:', error);
        }
    }

    // é‡ç½®ç»“æœé¢æ¿
    function resetResultPanels() {
        const emptyStates = {
            'entities-tab': { icon: 'ğŸ·ï¸', text: 'æš‚æ— å®ä½“æ•°æ®', hint: 'ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è‡ªåŠ¨è¯†åˆ«å®ä½“' },
            'relations-tab': { icon: 'ğŸ”—', text: 'æš‚æ— å…³ç³»æ•°æ®', hint: 'ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è‡ªåŠ¨æå–å…³ç³»' },
            'events-tab': { icon: 'ğŸ“…', text: 'æš‚æ— äº‹ä»¶æ•°æ®', hint: 'ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è‡ªåŠ¨è¯†åˆ«äº‹ä»¶' },
            'enhanced-tab': { icon: 'ğŸ§ ', text: 'æš‚æ— è¯­ä¹‰å¢å¼ºæ•°æ®', hint: 'ä¸Šä¼ æ–‡æ¡£å,ç³»ç»Ÿå°†è¿›è¡Œè¯­ä¹‰å¢å¼º' }
        };

        Object.entries(emptyStates).forEach(([id, state]) => {
            const tab = document.getElementById(id);
            if (tab) {
                tab.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">${state.icon}</div>
                        <p>${state.text}</p>
                        <p style="font-size: 0.9rem; margin-top: 10px;">${state.hint}</p>
                    </div>
                `;
            }
        });
    }

    // æ˜¾ç¤ºç»“æœ - å®Œå…¨ä¿®å¤çš„ç‰ˆæœ¬
    function displayResults(result) {
        const entities = result.entities?.entities || result.entity_standardization?.standardized_entities || [];
        const entitiesTab = document.getElementById('entities-tab');
        if (entitiesTab) {
            entitiesTab.innerHTML = entities.length > 0
                ? entities.map(e => `<span class="entity-tag">${e.word || e.label} (${e.label || e.type})</span>`).join('')
                : '<div class="empty-state"><div class="empty-state-icon">ğŸ·ï¸</div><p>æš‚æ— å®ä½“æ•°æ®</p></div>';
        }
        document.getElementById('entityCount').textContent = entities.length;

        const relations = result.all_relations?.relations || result.relations?.relations || [];
        const relationsTab = document.getElementById('relations-tab');
        if (relationsTab) {
            relationsTab.innerHTML = relations.length > 0
                ? relations.map(r => `<div class="relation-item"><strong>${r[0]}</strong> â†’ ${r[1]} â†’ <strong>${r[2]}</strong></div>`).join('')
                : '<div class="empty-state"><div class="empty-state-icon">ğŸ”—</div><p>æš‚æ— å…³ç³»æ•°æ®</p></div>';
        }

        const events = result.events?.events || [];
        const eventsTab = document.getElementById('events-tab');

        if (eventsTab) {
            if (events.length > 0) {
                const eventsHtml = events.map((event, index) => {
                    if (typeof event === 'string') {
                        return `<div class="event-item"><strong>äº‹ä»¶ ${index + 1}:</strong> ${event}</div>`;
                    }

                    if (typeof event === 'object' && event !== null) {
                        let details = [`<strong>äº‹ä»¶ ${index + 1}:</strong> ${event.name || event.description || 'æœªå‘½åäº‹ä»¶'}`];

                        const fields = {
                            'type': 'ç±»å‹',
                            'date': 'æ—¥æœŸ',
                            'time': 'æ—¶é—´',
                            'organizer': 'ç»„ç»‡æ–¹',
                            'participants': 'å‚ä¸è€…',
                            'location': 'åœ°ç‚¹',
                            'focus': 'å…³æ³¨ç‚¹',
                            'description': 'æè¿°'
                        };

                        Object.entries(fields).forEach(([key, label]) => {
                            if (event[key]) {
                                const value = Array.isArray(event[key]) ? event[key].join(', ') : event[key];
                                details.push(`<span style="color: #667eea;">${label}:</span> ${value}`);
                            }
                        });

                        if (event.sub_events && Array.isArray(event.sub_events) && event.sub_events.length > 0) {
                            details.push(`<span style="color: #667eea;">å­äº‹ä»¶:</span> ${event.sub_events.join(', ')}`);
                        }

                        if (event.sub_topics && Array.isArray(event.sub_topics) && event.sub_topics.length > 0) {
                            details.push(`<span style="color: #667eea;">å­ä¸»é¢˜:</span> ${event.sub_topics.join(', ')}`);
                        }

                        return `<div class="event-item">${details.join('<br>')}</div>`;
                    }

                    return `<div class="event-item">æœªçŸ¥äº‹ä»¶æ ¼å¼</div>`;
                }).join('');

                eventsTab.innerHTML = eventsHtml;
            } else {
                eventsTab.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ğŸ“…</div>
                        <p>æš‚æ— äº‹ä»¶æ•°æ®</p>
                    </div>
                `;
            }
        }

        document.getElementById('eventCount').textContent = events.length;

        const enhanced = result.semantic_enhancement?.details || [];
        const enhancedTab = document.getElementById('enhanced-tab');
        if (enhancedTab) {
            enhancedTab.innerHTML = enhanced.length > 0
                ? enhanced.map(e => {
                    if (e.enhanced === false) return `<div class="relation-item">${e.original} - æœªæ‰¾åˆ°å¢å¼ºä¿¡æ¯</div>`;
                    return `<div class="relation-item"><strong>${e.original}</strong><br>QID: ${e.qid || 'N/A'}<br>æè¿°: ${e.enhanced_description || 'N/A'}</div>`;
                }).join('')
                : '<div class="empty-state"><div class="empty-state-icon">ğŸ§ </div><p>æš‚æ— è¯­ä¹‰å¢å¼ºæ•°æ®</p></div>';
        }
    }

    // åŠ è½½æœ€æ–°åˆ†æç»“æœ
    async function loadLatestAnalysis() {
        try {
            const response = await fetch('/get_latest_analysis');
            if (!response.ok) return;

            const data = await response.json();
            if (data.status === 'success' && data.data && data.data.result) {
                displayResults(data.data.result);
                const fileInfo = document.getElementById('fileInfo');
                const fileName = document.getElementById('fileName');
                if (fileInfo && fileName) {
                    fileName.textContent = `${data.data.file_name} (ä¸Šæ¬¡å¤„ç†)`;
                    fileInfo.classList.add('active');
                }
            }
        } catch (error) {
            console.error('åŠ è½½åˆ†æç»“æœå¤±è´¥:', error);
        }
    }

    // åˆ‡æ¢æ ‡ç­¾
    function switchTab(tabName) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabName);
        });
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.toggle('active', content.id === `${tabName}-tab`);
        });
    }

    // æ˜¾ç¤º/éšè—å¤„ç†è¦†ç›–å±‚
    function showProcessing(show, message = '') {
        const overlay = document.getElementById('processingOverlay');
        overlay.classList.toggle('active', show);
        if (show && message) {
            document.getElementById('processingMessage').textContent = message;
            updateProgressBar(0);
        }
    }

    // å¯¼å‡ºå›¾è°±
    async function exportGraph() {
        try {
            if (!allNodes || allNodes.length === 0) {
                alert('å½“å‰å›¾è°±ä¸ºç©º,æ— æ³•å¯¼å‡º!');
                return;
            }

            const response = await fetch('/export_graph');
            if (!response.ok) throw new Error(`å¯¼å‡ºå¤±è´¥: HTTP ${response.status}`);

            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `knowledge_graph_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            alert('å›¾è°±å¯¼å‡ºæˆåŠŸ!');
        } catch (error) {
            console.error('å¯¼å‡ºé”™è¯¯:', error);
            alert('å¯¼å‡ºå¤±è´¥: ' + error.message);
        }
    }

    // CSV å¯¼å‡º
    async function exportGraphAsCsv() {
        try {
            if (!allNodes || allNodes.length === 0) {
                alert('å½“å‰å›¾è°±ä¸ºç©º,æ— æ³•å¯¼å‡º!');
                return;
            }

            const response = await fetch('/export_graph');
            if (!response.ok) throw new Error(`å¯¼å‡ºå¤±è´¥: HTTP ${response.status}`);

            const data = await response.json();

            let nodesCsv = 'ID,æ ‡ç­¾,ç±»å‹,æè¿°\n';
            data.graph.nodes.forEach(node => {
                nodesCsv += `"${node.name}","${node.label || ''}","${node.type || ''}","${node.description || ''}"\n`;
            });

            let edgesCsv = 'æºèŠ‚ç‚¹,å…³ç³»,ç›®æ ‡èŠ‚ç‚¹,æ˜¯å¦æ¨æ–­\n';
            data.graph.edges.forEach(edge => {
                edgesCsv += `"${edge.source}","${edge.type}","${edge.target}","${edge.inferred ? 'æ˜¯' : 'å¦'}"\n`;
            });

            downloadFile(nodesCsv, `nodes_${Date.now()}.csv`, 'text/csv');
            setTimeout(() => {
                downloadFile(edgesCsv, `edges_${Date.now()}.csv`, 'text/csv');
            }, 500);

            alert('CSV æ–‡ä»¶å·²å¯¼å‡º(èŠ‚ç‚¹å’Œè¾¹)');
        } catch (error) {
            console.error('å¯¼å‡ºé”™è¯¯:', error);
            alert('å¯¼å‡ºå¤±è´¥: ' + error.message);
        }
    }

    // ä¸‹è½½æ–‡ä»¶è¾…åŠ©å‡½æ•°
    function downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }

    // å¯¼å…¥æ–‡ä»¶å¤„ç†
    function handleImportFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.name.endsWith('.json')) {
            alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„å›¾è°±æ–‡ä»¶!');
            return;
        }

        importGraph(file);
    }

    // å¯¼å…¥å›¾è°±
    async function importGraph(file) {
        if (!confirm(`ç¡®å®šè¦å¯¼å…¥å›¾è°±å—?\nè¿™å°†æ·»åŠ æ–‡ä»¶ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å’Œå…³ç³»åˆ°å½“å‰å›¾è°±ã€‚\n\næ–‡ä»¶å: ${file.name}`)) {
            document.getElementById('importFileInput').value = '';
            return;
        }

        const formData = new FormData();
        formData.append('file', file);

        try {
            showProcessing(true, 'æ­£åœ¨å¯¼å…¥å›¾è°±...');

            const response = await fetch('/import_graph', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.detail || `HTTP ${response.status}`);
            }

            const result = await response.json();
            showProcessing(false);
            alert(`å›¾è°±å¯¼å…¥æˆåŠŸ!\n\nèŠ‚ç‚¹: ${result.nodes_imported}\nå…³ç³»: ${result.edges_imported}`);
            await loadGraph();
        } catch (error) {
            console.error('å¯¼å…¥é”™è¯¯:', error);
            showProcessing(false);
            alert('å¯¼å…¥å¤±è´¥: ' + error.message);
        } finally {
            document.getElementById('importFileInput').value = '';
        }
    }

    // åˆ‡æ¢å†å²è§†å›¾
    async function toggleHistoryView() {
        const historyList = document.getElementById('historyList');
        const btn = document.getElementById('viewHistoryBtn');

        if (historyList.style.display === 'none') {
            await loadHistoryList();
            historyList.style.display = 'block';
            btn.textContent = 'éšè—å†å²';
        } else {
            historyList.style.display = 'none';
            btn.textContent = 'æŸ¥çœ‹å†å²';
        }
    }

    // åŠ è½½å†å²åˆ—è¡¨
    async function loadHistoryList() {
        try {
            const response = await fetch('/get_analysis_history?limit=10');
            const data = await response.json();
            const historyList = document.getElementById('historyList');

            if (data.status === 'success' && data.history && data.history.length > 0) {
                historyList.innerHTML = data.history.map(item => {
                    const date = new Date(item.processed_at).toLocaleString('zh-CN');
                    return `
                        <div style="padding: 10px; margin: 5px 0; background: rgba(102, 126, 234, 0.1);
                                    border-radius: 5px; cursor: pointer; border-left: 3px solid var(--primary-color);"
                             onclick="loadAnalysisById('${item.task_id}')">
                            <div style="font-weight: bold; color: var(--text-primary);">${item.file_name}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">
                                ${date} | ${item.processing_time?.toFixed(2)}ç§’
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                historyList.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">æš‚æ— å†å²è®°å½•</div>';
            }
        } catch (error) {
            console.error('åŠ è½½å†å²å¤±è´¥:', error);
            document.getElementById('historyList').innerHTML = '<div style="padding: 20px; text-align: center; color: var(--danger-color);">åŠ è½½å¤±è´¥</div>';
        }
    }

    // åŠ è½½æŒ‡å®šIDçš„åˆ†æç»“æœ
    async function loadAnalysisById(taskId) {
        try {
            const response = await fetch(`/get_analysis_by_id/${taskId}`);
            const data = await response.json();

            if (data.status === 'success' && data.data && data.data.result) {
                displayResults(data.data.result);
                alert(`å·²åŠ è½½: ${data.data.file_name}`);
            } else {
                alert('åŠ è½½å¤±è´¥');
            }
        } catch (error) {
            console.error('åŠ è½½å¤±è´¥:', error);
            alert('åŠ è½½å¤±è´¥');
        }
    }

    // CSVå¯¼å…¥åŠŸèƒ½
    let selectedNodesFile = null;
    let selectedEdgesFile = null;

    async function handleCsvNodesImport(event) {
        selectedNodesFile = event.target.files[0];
        if (!selectedNodesFile) return;

        if (!selectedNodesFile.name.endsWith('.csv')) {
            alert('è¯·é€‰æ‹©CSVæ ¼å¼çš„èŠ‚ç‚¹æ–‡ä»¶!');
            selectedNodesFile = null;
            event.target.value = '';
            return;
        }

        if (confirm('èŠ‚ç‚¹æ–‡ä»¶å·²é€‰æ‹©!\n\næ˜¯å¦ä¹Ÿè¦å¯¼å…¥è¾¹å…³ç³»CSVæ–‡ä»¶?\n\nç‚¹å‡»"ç¡®å®š"é€‰æ‹©è¾¹æ–‡ä»¶,ç‚¹å‡»"å–æ¶ˆ"ä»…å¯¼å…¥èŠ‚ç‚¹ã€‚')) {
            document.getElementById('importCsvEdgesInput').click();
        } else {
            await importCsvFiles();
        }
    }

    async function handleCsvEdgesImport(event) {
        selectedEdgesFile = event.target.files[0];
        if (selectedEdgesFile && !selectedEdgesFile.name.endsWith('.csv')) {
            alert('è¯·é€‰æ‹©CSVæ ¼å¼çš„è¾¹æ–‡ä»¶!');
            selectedEdgesFile = null;
            event.target.value = '';
            return;
        }
        await importCsvFiles();
    }

    async function importCsvFiles() {
        if (!selectedNodesFile) {
            alert('è¯·å…ˆé€‰æ‹©èŠ‚ç‚¹CSVæ–‡ä»¶!');
            return;
        }

        const formData = new FormData();
        formData.append('nodes_file', selectedNodesFile);
        if (selectedEdgesFile) {
            formData.append('edges_file', selectedEdgesFile);
        }

        try {
            showProcessing(true, 'æ­£åœ¨å¯¼å…¥CSVæ–‡ä»¶...');

            const response = await fetch('/import_analysis_csv', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.detail || `HTTP ${response.status}`);
            }

            const result = await response.json();
            showProcessing(false);
            alert(`CSVå¯¼å…¥æˆåŠŸ!\n\nèŠ‚ç‚¹: ${result.nodes_imported}\nå…³ç³»: ${result.edges_imported}`);
            await loadGraph();
        } catch (error) {
            console.error('CSVå¯¼å…¥é”™è¯¯:', error);
            showProcessing(false);
            alert('CSVå¯¼å…¥å¤±è´¥: ' + error.message);
        } finally {
            document.getElementById('importCsvNodesInput').value = '';
            document.getElementById('importCsvEdgesInput').value = '';
            selectedNodesFile = null;
            selectedEdgesFile = null;
        }
    }
</script>
</body>
</html>